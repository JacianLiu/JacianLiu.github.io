<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.8.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>一文详解Spring循环依赖 - Jacian&#39;s Blog</title><meta name="description" content="什么是循环依赖？大家都知道spring的核心是一个实现了AOP的IOC容器，那么IOC容器对于bean的初始化，会遇到以下情况：当BeanA初始化时，它依赖的对象BeanB也需要执行初始化，如果BeanB里也依赖了BeanA,则又会开始执行BeanA的初始化，那么这样会无限循环，导致初始化异常如下所示。"><meta name="keywords" content="Spring"><meta property="og:type" content="article"><meta property="og:title" content="一文详解Spring循环依赖"><meta property="og:url" content="https://blog.jacian.com/2020/12/1608133537885/index.html"><meta property="og:site_name" content="Jacian&#39;s Blog"><meta property="og:description" content="什么是循环依赖？大家都知道spring的核心是一个实现了AOP的IOC容器，那么IOC容器对于bean的初始化，会遇到以下情况：当BeanA初始化时，它依赖的对象BeanB也需要执行初始化，如果BeanB里也依赖了BeanA,则又会开始执行BeanA的初始化，那么这样会无限循环，导致初始化异常如下所示。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.jacian.com/note/img/20200826163449.png"><meta property="og:updated_time" content="2020-12-17T07:44:36.558Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="一文详解Spring循环依赖"><meta name="twitter:description" content="什么是循环依赖？大家都知道spring的核心是一个实现了AOP的IOC容器，那么IOC容器对于bean的初始化，会遇到以下情况：当BeanA初始化时，它依赖的对象BeanB也需要执行初始化，如果BeanB里也依赖了BeanA,则又会开始执行BeanA的初始化，那么这样会无限循环，导致初始化异常如下所示。"><meta name="twitter:image" content="https://img.jacian.com/note/img/20200826163449.png"><link rel="icon" href="https://img.jacian.com/boyfavicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.min.css"><link rel="stylesheet" href="/css/all.css"><link rel="stylesheet" href="/google.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-145676372-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-145676372-1")</script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/"><img src="https://img.jacian.com/jfavicon.png" alt="一文详解Spring循环依赖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/contact">联系我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/JacianLiu"><i class="fab fa-github"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section" style="background:url(https://img.jacian.com/background1.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:100% 100%"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>一文详解Spring循环依赖</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2020-12-16T15:45:37.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2020-12-16</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2020-12-17T07:44:36.558Z"><i class="far fa-calendar-check">&nbsp;</i>2020-12-17</time><div class="level-item"><a class="has-link-grey -link" href="/categories/Spring/">Spring</a></div><span class="level-item has-text-grey">22 分钟 读完 (大约 3313 个字)</span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"></h1><div class="content"><h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>大家都知道spring的核心是一个实现了AOP的IOC容器，那么IOC容器对于bean的初始化，会遇到以下情况：当BeanA初始化时，它依赖的对象BeanB也需要执行初始化，如果BeanB里也依赖了BeanA,则又会开始执行BeanA的初始化，那么这样会无限循环，导致初始化异常如下所示。<br><a id="more"></a></p><p><img src="https://img-blog.csdnimg.cn/20201206003911766.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzaXNu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Spring已经很好的解决了这个问题，这个解决方法就是三级缓存。</p><h2 id="什么是三级缓存？"><a href="#什么是三级缓存？" class="headerlink" title="什么是三级缓存？"></a>什么是三级缓存？</h2><p>我们以上图中A、B互相依赖为例，spring为了解决循环依赖问题，做了以下步骤：</p><ul><li><p>A通过反射创建的“初级bean”a放入到三级缓存中，再执行a的属性填充，这时发现依赖B，开启B的初始化。</p></li><li><p>B通过反射生成的“初级bean”b放入到三级缓存中，再执行b的属性填充，这时发现依赖A，开启A的初始化。</p></li><li><p>从三级缓存中找到a，A不再创建新对象，把它移动到二级缓存中，返回a。</p></li><li><p>b拿到a的引用，设置到b对应的字段上，属性填充完成，将b从三级缓存暴露到一级缓存中，返回b。</p></li><li><p>a拿到b的引用，设置到a对应的字段上，属性填充完成，将a从二级缓存暴露到一级缓存中，返回a，A对应的实例Bean初始化完成。</p><p><strong>其简易时序图</strong>：</p></li></ul><p><img src="https://img.jacian.com/note/img/20201216234410.png" alt="在这里插入图片描述"></p><p><strong>逻辑图如下：</strong></p><p><img src="https://img.jacian.com/note/img/20201216234418.jpeg" alt="在这里插入图片描述"></p><p><strong>咱们再看看三级缓存的存储结构</strong>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="hljs-comment">/** 一级缓存，初始化完成的SpringBean均放置其中 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="hljs-comment">/** 二级缓存，反射完成后，还未填充属性的初级对象但是其他对象查询过时从三级中移动到二级 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="hljs-comment">/** 三级缓存，反射完成后，还未填充属性的初级对象放置其中 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br><span class="line"><span class="hljs-number">1234567891011</span></span><br></pre></td></tr></table></figure><p>为什么三级缓存earlySingletonObjects和二级缓存singletonFactories的初始容量16，而一级缓存容量为256呢？笔者认为因为二级、三级仅仅是在处理依赖时会使用到，这种多重循环依赖的情况在实际项目中应该是少数，所以不用使用太大的空间。而最终spring实例化完成的bean会放置在一级缓存中，所以默认容量会调大一些，毕竟spring有很多自身的bean也是放置在这里面的，比如systemEnvironment、systemProperties、messageSource、applicationEventMulticaster等。</p><h2 id="spring的源码阅读"><a href="#spring的源码阅读" class="headerlink" title="spring的源码阅读"></a>spring的源码阅读</h2><p>当单例对象不存在时，会通过org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)方法来获取单例对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="hljs-comment">// 在一级缓存singletonObjects中拿到为空 </span></span><br><span class="line">			<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">				<span class="hljs-comment">/** 省略状态检查部分代码 */</span></span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">				<span class="hljs-keyword">boolean</span> newSingleton = <span class="hljs-keyword">false</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">					<span class="hljs-comment">// 传进来的调用，lamda表达式使用</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="hljs-comment">// *********重要*********：singletonFactory.getObject()执行完毕，标记此类已经初始化完成</span></span><br><span class="line">					<span class="hljs-comment">// bean初始化完成，标记为新的单例对象</span></span><br><span class="line">					newSingleton = <span class="hljs-keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">					<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-comment">// 如果是新的单例对象，暴露到一级缓存中</span></span><br><span class="line">				<span class="hljs-keyword">if</span> (newSingleton) &#123;</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">	 * Add the given singleton object to the singleton cache of this factory.</span></span><br><span class="line"><span class="hljs-comment">	 * &lt;p&gt;To be called for eager registration of singletons.</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> singletonObject the singleton object</span></span><br><span class="line"><span class="hljs-comment">	 */</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="hljs-comment">// 加入到一级缓存，从二级和三级缓存中移除;</span></span><br><span class="line">			<span class="hljs-keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">			<span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">			<span class="hljs-keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">			<span class="hljs-keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的singletonFactory.getObject() 无疑是执行创建的关键代码：</p><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">	 * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="hljs-comment">	 * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="hljs-comment">	 */</span></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function">			<span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// 拿到Bd</span></span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">		<span class="hljs-comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">		<span class="hljs-comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">		<span class="hljs-comment">// 获得类信息</span></span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">			mbdToUse = <span class="hljs-keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// Prepare method overrides.</span></span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 检查该bean是否有重载方法</span></span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">			<span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			<span class="hljs-comment">// 尝试获取代理对象;</span></span><br><span class="line">			<span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">				<span class="hljs-keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">			<span class="hljs-comment">// 进入，真真正正创建bean</span></span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>再来看看doCreateBean方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">	 * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="hljs-comment">	 * at this point, e.g. checking &#123;<span class="hljs-doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="hljs-comment">	 * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="hljs-comment">	 * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="hljs-comment">	 * <span class="hljs-doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="hljs-comment">	 */</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function">			<span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;</span><br><span class="line">		<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">			<span class="hljs-comment">// 创建 Bean 实例，仅仅调用构造方法，但是尚未设置属性</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">		<span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="hljs-comment">// 暴露到三级缓存中</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// 初始化bean实例</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">			<span class="hljs-comment">// Bean属性填充</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			<span class="hljs-comment">// 调用初始化方法，应用BeanPostProcessor后置处理器</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="hljs-comment">// 调用一次getSingleton(beanName, false)方法-&gt;" + beanName)，只从一级、二级缓存中拿，传入false不需要从三级添加到二级缓存;</span></span><br><span class="line">            <span class="hljs-comment">// 核心逻辑是：如果提前暴露到了二级，则返回二级缓存中的对象引用，此时可能获取得到的是原对象的代理对象。因为AOP动态代理时，会将对象提升二级缓存，本文不再详述此问题</span></span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);</span><br><span class="line">			<span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					<span class="hljs-comment">/** 省略部分代码,检查依赖对象是否均创建完成 */</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 初始化完成后一些注册操作</span></span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>从doCreateBean方法可以看出：先调用构造方法，生成初级bean，然后暴露到三级缓存，然后执行属性填充，最表标记bean初始化完成，如果二级缓存有，则替换引用，最后完成注册并返回对象。</p><p>那么这个填充属性方法populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) 又做了什么呢？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line"></span><br><span class="line">		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">		<span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">			<span class="hljs-comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">		PropertyDescriptor[] filteredPds = <span class="hljs-keyword">null</span>;</span><br><span class="line">		<span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">						<span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">						&#125;</span><br><span class="line">						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">							<span class="hljs-keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					pvs = pvsToUse;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">			<span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			&#125;</span><br><span class="line">			checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">			applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>代码比较多，核心思想就是获取这个bean里的所有依赖bean，然后调用applyPropertyValues方法去创建对应的依赖bean，并设置到对应的属性上。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyPropertyValues</span><span class="hljs-params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="hljs-keyword">new</span> BeanDefinitionValueResolver(<span class="hljs-keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">		<span class="hljs-keyword">boolean</span> resolveNecessary = <span class="hljs-keyword">false</span>;</span><br><span class="line">		<span class="hljs-keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="hljs-keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                String propertyName = pv.getName();</span><br><span class="line">                Object originalValue = pv.getValue();</span><br><span class="line">                <span class="hljs-comment">// *** 将依赖的属性目标，转化为初始化完成后的bean</span></span><br><span class="line">                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">                Object convertedValue = resolvedValue;</span><br><span class="line">                <span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">                <span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="hljs-comment">/** 省略部分代码 */</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>valueResolver.resolveValueIfNecessary方法经过一些的方法，最终调用beanFactory.getBean，这个方法会回到开始进行新一轮的创建bean</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">resolveInnerBean</span><span class="hljs-params">(Object argName, String innerBeanName, BeanDefinition innerBd)</span> </span>&#123;</span><br><span class="line">    String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">    <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.beanFactory.registerDependentBean(dependsOnBean, actualInnerBeanName);</span><br><span class="line">            <span class="hljs-comment">// 初始化bean</span></span><br><span class="line">            <span class="hljs-keyword">this</span>.beanFactory.getBean(dependsOnBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allowEarlyReference传入true，对于新的bean，已经在三级缓存中存在，会将三级缓存转移到二级缓存，并返回bean，不用真正的去创建一个bean。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="hljs-keyword">boolean</span> needWarn = <span class="hljs-keyword">true</span>;</span><br><span class="line">		Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">				logger.warn(<span class="hljs-string">"当前bean已注册，从一级earlySingletonObjects中拿不到-&gt;"</span> + beanName + <span class="hljs-string">"："</span> + singletonObject);</span><br><span class="line">				singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					logger.warn(<span class="hljs-string">"当前bean已注册，从二级缓存earlySingletonObjects中拿不到-&gt;"</span> + beanName + <span class="hljs-string">"："</span> + singletonObject);</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">						needWarn = <span class="hljs-keyword">false</span>;</span><br><span class="line">						logger.warn(<span class="hljs-string">"当前bean已注册，从三级singletonFactories中拿到，并移动到二级缓存earlySingletonObjects-&gt;"</span> + beanName + <span class="hljs-string">"  ： "</span> + singletonObject);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> (needWarn) &#123;</span><br><span class="line">			logger.warn(<span class="hljs-string">"从三级缓存中查询，调用DefaultSingletonBeanRegistry.getSingleton(beanName, allowEarlyReference)-&gt;得到"</span> + beanName + <span class="hljs-string">":"</span> + singletonObject + <span class="hljs-string">"   ,allowEarlyReference："</span> + allowEarlyReference);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>所以第三步的Bean B属性填充方法此时完成，Bean B被加载到一级缓存中。由此回溯，Bean A的属性填充完成，Bean A被加载到一级缓存中。可结合本文最开始给出的时序图进行参考。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="为什么要用三级缓存而不是二级"><a href="#为什么要用三级缓存而不是二级" class="headerlink" title="为什么要用三级缓存而不是二级?"></a>为什么要用三级缓存而不是二级?</h3><p>我们可以从三级缓存的值类型看出，一、二级的值均为Spring Bean对象的引用，三级对象则为ObjectFactory的引用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="hljs-comment">/** 一级缓存，初始化完成的SpringBean均放置其中 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="hljs-comment">/** 二级缓存，反射完成后，还未填充属性的初级对象但是其他对象查询过时从三级中移动到二级 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="hljs-comment">/** 三级缓存，反射完成后，还未填充属性的初级对象放置其中 */</span></span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br></pre></td></tr></table></figure><h4 id="为什么要有ObjectFactory类型的第三级缓存？"><a href="#为什么要有ObjectFactory类型的第三级缓存？" class="headerlink" title="为什么要有ObjectFactory类型的第三级缓存？"></a>为什么要有ObjectFactory类型的第三级缓存？</h4><p>将对象从三级缓存singletonFactories中移动到二级缓存时，会执行ObjectFactory的getBean方法，再调用到getEarlyBeanReference方法，最终遍历该Bean对应的所有SmartInstantiationAwareBeanPostProcessor进行执行；熟悉spring的朋友们肯定知道，SmartInstantiationAwareBeanPostProcessor是Spring Aop动态代理相关属性处理器。执行后获得一个新的bean，该bean是原bean代理对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 新生成一个Factory对象，并设置其getBean方法为getEarlyBeanReference</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"><span class="hljs-comment">// 等价于以下代码</span></span><br><span class="line"><span class="hljs-comment">/* addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span></span><br><span class="line"><span class="hljs-comment">				@Override</span></span><br><span class="line"><span class="hljs-comment">				public Object getObject() throws BeansException &#123;</span></span><br><span class="line"><span class="hljs-comment">					return getEarlyBeanReference(beanName, mbd, bean);</span></span><br><span class="line"><span class="hljs-comment">				&#125;</span></span><br><span class="line"><span class="hljs-comment">			&#125;); */</span></span><br><span class="line"><span class="hljs-number">123456789</span></span><br><span class="line"><span class="hljs-comment">// getEarlyBeanReference方法：将会遍历其所有的SmartInstantiationAwareBeanPostProcessor（智能化属性处理器，然后进行执行）</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>也就是说，三级缓存 存在的目的就是增强对象，当需要使用spring的aop功能时返回代理对象，如果咱们永远用不到代理对象，三级缓存理论上可以不用。</p><h4 id="既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？"><a href="#既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？" class="headerlink" title="既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？"></a>既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？</h4><p>理论上可以，只需要两级缓存就可以解决循环依赖的问题，但在处理循环依赖的过程，一级缓存中将可能同时存在完整Spring Bean A 和 半成品Spring Bean B。三级对象getObject之后直接放置到二级，最后再刷到一级，二级到一级这个过程中并无额外的处理。</p><p>那么为什么spring要使用三级呢？笔者认为一是为了规范各级缓存职责单一原则，不让一级缓存中出现完整的bean和半成品bean；二是为了避免半成品bean被其他线程获取后进行调用，降低实现的难度。</p><blockquote><p>文章转自：<a href="https://blog.csdn.net/ksisn/article/details/110730050" target="_blank" rel="noopener">https://blog.csdn.net/ksisn/article/details/110730050</a></p><p>文章转自：<a href="https://blog.csdn.net/ksisn/article/details/110730050" target="_blank" rel="noopener">https://blog.csdn.net/ksisn/article/details/110730050</a></p><p>文章转自：<a href="https://blog.csdn.net/ksisn/article/details/110730050" target="_blank" rel="noopener">https://blog.csdn.net/ksisn/article/details/110730050</a></p></blockquote></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://blog.jacian.com/2020/12/1608133537885/">一文详解Spring循环依赖</a></li><li><strong>本文作者：</strong><a href="https://blog.jacian.com">Jacian</a></li><li><strong>本文链接：</strong><a href="https://blog.jacian.com/2020/12/1608133537885/">https://blog.jacian.com/2020/12/1608133537885/</a></li><li><strong>发布时间：</strong>2020-12-16</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/Spring/">Spring</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="https://img.jacian.com/ali_pay.png" alt="支付宝"></div></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i> </span><span>微信</span><div class="qrcode"><img src="https://img.jacian.com/wx_pay.png" alt="微信"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/2020/12/1608132723882/"><span class="level-item" style="color:#fff">IOC容器加载流程</span> <i class="level-item fas fa-chevron-right" style="color:#fff"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="valine-thread" class="content"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.4/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"joKiamUtP8VJ4WkJllHbMnI3-gzGzoHsz",app_key:"A5old1pGj3hay75cdNA0mdXg",placeholder:"ヾﾉ≧∀≦)o来啊，快活啊!"})</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered" style="flex-shrink:1"><div><figure class="image is-128x128 has-mb-6"><img src="https://img.jacian.com/squ_zip.png" alt="Jacian"></figure><p class="is-size-4 is-block">Jacian</p><p class="is-size-6 is-block">Jacian&#39;s Blog</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Beijing,China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><div><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">17</p></a></div></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/JacianLiu" target="_blank">关注我</a></div><div class="level is-mobile"><a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://github.com/JacianLiu"><i class="fab fa-github"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="博客园" href="https://www.cnblogs.com/jacian"><i class="fab fa-blogger-b"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="mail" href="mailto:JacianLiu@gmail.com"><i class="fas fa-envelope"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#什么是循环依赖？"><span class="has-mr-6">1</span> <span>什么是循环依赖？</span></a></li><li><a class="is-flex" href="#什么是三级缓存？"><span class="has-mr-6">2</span> <span>什么是三级缓存？</span></a></li><li><a class="is-flex" href="#spring的源码阅读"><span class="has-mr-6">3</span> <span>spring的源码阅读</span></a></li><li><a class="is-flex" href="#其他问题"><span class="has-mr-6">4</span> <span>其他问题</span></a><ul class="menu-list"><li><a class="is-flex" href="#为什么要用三级缓存而不是二级"><span class="has-mr-6">4.1</span> <span>为什么要用三级缓存而不是二级?</span></a><ul class="menu-list"><li><a class="is-flex" href="#为什么要有ObjectFactory类型的第三级缓存？"><span class="has-mr-6">4.1.1</span> <span>为什么要有ObjectFactory类型的第三级缓存？</span></a></li><li><a class="is-flex" href="#既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？"><span class="has-mr-6">4.1.2</span> <span>既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？</span></a></li></ul></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer" style="height:50px"><div class="container" style="height:50px"><div class="level" style="height:50px"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/"><img src="https://img.jacian.com/jfavicon.png" alt="一文详解Spring循环依赖" height="28"></a></div><div class="container" style="text-align:center">&copy; 2020 <a href="/">Jacian</a>&nbsp;&nbsp;&nbsp;&nbsp; <a class="has-text-black" href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备19039488号</a></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i>&nbsp;<i class="fab fa-creative-commons-by"></i>&nbsp;<i class="fab fa-creative-commons-nc"></i>&nbsp;<i class="fab fa-creative-commons-sa"></i>&nbsp;</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"></body></html>